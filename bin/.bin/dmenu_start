#!/bin/bash


# Get colors:
XRDB="$(xrdb -query)"
FG="#$(echo "$XRDB" | sed -n 's/URxvt\*foreground:.*\#//p')"
BG="#$(echo "$XRDB" | sed -n 's/URxvt\*background:.*\#//p')"
#UNDERLINE="\#$(echo "$XRDB" | sed -n 's/\*color8:.*\#//p')"

# Get screen resolution:
RES="$(xrandr -q | egrep -oe 'current [0-9]+ x [0-9]+' | cut -c8-)"
XX="$(echo $RES | cut -d' ' -f1)"
XY="$(echo $RES | cut -d' ' -f3)"

w="550" # Width of box
h="20" # Height of single line
l="10" # Lines in box

let "x = ($XX - $w) / 2"
let "boxh = ($l + 1) * $h"
let "y = ($XY - $boxh) / 2"

# Options:
B="" # " -b" # Bottom
Q="" # " -q" # Quiet
F="" # " -f" # Fast keyboard grab. Potential freezei
R="" # " -r" # Filter. Execute all items in remaining list
I="" # " -i" # Case sensitivity
Z="" # " -z" # Fuzzy matching
T=" -t" # Token matching. Overrides -z
MASK="" # " -mask" # Mask input with *
NOINPUT="" # " -noinput" # Ignores input from stdin
S="" # " -s 0" # Screen to appear in
NAME="" # " -name dmenu" # Window name
CLASS="" # " -class Dmenu" # Window class
O=" -o 0.75" # Opacity
DIM=" -dim 0.04" # Dim opacity of screen
DC=" -dc $BG" # Dim color of screen
L=" -l $l" # Lines for vertical list
H=" -h $h" # Height of a single line
P=" -p $" # Prompt
FN=" -fn TamzenForPowerline:pixelsize=14" # Font
X=" -x $x" # X offset
Y=" -y $y" # Y offset
W=" -w $w" # Width
NB=" -nb $BG" # Normal background
NF=" -nf $FG" # Normal foreground
SB=" -sb $FG" # Selected background
SF=" -sf $BG" # Selected foreground

#CACHE_DIR=${XDG_CACHE_HOME:-"$HOME/.cache"}
#HIST=" -hist $CACHE_DIR/dmenu_history" # History file
#UH=" -uh 2" # Hight of underline
#UC=" -uc $UNDERLINE" # Underline color


# Purpose dependent options and preparations:
case $1 in
program)
	cachedir=${XDG_CACHE_HOME:-"$HOME/.cache"}
	if [ -d "$cachedir" ]; then
		cache=$cachedir/dmenu_run
		historyfile=$cachedir/dmenu_history
	else			# if no xdg dir, fall back to dotfiles in ~
		cache=$HOME/.dmenu_cache
		historyfile=$HOME/.dmenu_history
	fi
	;;
overlay)
	DIM=""
	DC=""
	P=""
	file="/tmp/.minimized"
	miniList=$(cat $file)
    if [ -z "$miniList" ] ; then
        miniList="  No hidden windows  "
    fi
	;;
esac

# Compile options
DMENU_CMD="dmenu$B$Q$F$R$I$Z$MASK$NOINPUT$S$NAME$CLASS$O$DIM$DC$L$H$P$FN$X$Y$W$NB$NF$SB$SF"

# Purpose dependent execution:
case $1 in
program)
	awk -v histfile=$historyfile '
		BEGIN {
			while( (getline < histfile) > 0 ) {
				sub("^[0-9]+\t","")
				print
				x[$0]=1
			}
		} !x[$0]++ ' "$cache" \
		| $DMENU_CMD \
		| awk -v histfile=$historyfile '
			BEGIN {
				FS=OFS="\t"
				while ( (getline < histfile) > 0 ) {
					count=$1
					sub("^[0-9]+\t","")
					fname=$0
					history[fname]=count
				}
				close(histfile)
			}
	
			{
				history[$0]++
				print
			}
	
			END {
				if(!NR) exit
				for (f in history)
					print history[f],f | "sort -t '\t' -k1rn >" histfile
			}
		' \
		| while read cmd; do ${SHELL:-"/bin/sh"} -c "$cmd" & done
	exit 0;
	;;
*)
	while read line ; do
		if [ "$line" == "" ] ; then
			break;
		fi
		if [ "$IN" == "" ] ; then
			IN=$line
		else
			IN="$IN"$'\n'"$line"
		fi
	done
esac
echo "$IN" | $DMENU_CMD
